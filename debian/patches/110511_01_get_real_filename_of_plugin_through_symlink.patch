Description: Get real filename of plugin through possible symlink
 uWSGI loads plugins by loading entrypoint symbol from plugin's shared library. Name of required symbol is computed as name of shared library's file without
 extension '.so'.
 .
 If plugin file is a symbolic link to real shared library and this symbolic
 link is named differently from shared library file, uWSGI will fail in finding
 needed symbol in plugin, as symbol name will be derived from symbolic link
 name.
 .
 This means that alternatives system can't be applied to plugins, as it works
 through making of symbolic link from some file to underlying alternative
 implementation.
 .
 This patch fixes the situation. It differs from original upstream version in
 resolving all levels of indirection (not only symlink->file, but also
 symlink->symlink->file etc.).
Origin: upstream, http://projects.unbit.it/hg/uwsgi/diff/17e8b8bd4dee/plugins.c
Author: Roberto De Ioris <roberto@unbit.it>
Author: Leonid Borisenko <leo.borisenko@gmail.com>
Forwarded: http://lists.unbit.it/pipermail/uwsgi/2011-May/002000.html
Applied-Upstream: 0.9.8-dev, http://projects.unbit.it/hg/uwsgi/rev/5d44da5f5988
Last-Update: 2011-05-11

Index: uwsgi/plugins.c
===================================================================
--- uwsgi.orig/plugins.c	2011-05-11 14:02:00.000000000 +0300
+++ uwsgi/plugins.c	2011-05-11 14:03:06.000000000 +0300
@@ -9,6 +9,8 @@
 	char *plugin_name;
 	char *plugin_entry_symbol;
 	struct uwsgi_plugin *up;
+	char linkpath_buf[1024], linkpath[1024];
+	int linkpath_size;
 	int i;
 
 	char *colon = strchr(plugin, ':');
@@ -71,7 +73,6 @@
 		plugin_name = uwsgi_concat4(UWSGI_PLUGIN_DIR, "/", plugin, "_plugin.so");
 	}
 	plugin_handle = dlopen(plugin_name, RTLD_NOW | RTLD_GLOBAL);
-	free(plugin_name);
 
         if (!plugin_handle) {
                 uwsgi_log( "%s\n", dlerror());
@@ -79,6 +80,30 @@
         else {
 		plugin_entry_symbol = uwsgi_concat2(plugin, "_plugin");
                 up = dlsym(plugin_handle, plugin_entry_symbol);
+		if (!up) {
+			// is it a link ?
+			memset(linkpath_buf, 0, 1024);
+			memset(linkpath, 0, 1024);
+			if ((linkpath_size = readlink(plugin_name, linkpath_buf, 1023)) > 0) {
+				do {
+					linkpath_buf[linkpath_size] = '\0';
+					strcpy(linkpath, linkpath_buf);
+				} while ((linkpath_size = readlink(linkpath, linkpath_buf, 1023)) > 0);
+				uwsgi_log("%s\n", linkpath);
+				free(plugin_entry_symbol);
+				up = dlsym(plugin_handle, plugin_entry_symbol);
+				char *slash = uwsgi_get_last_char(linkpath, '/');
+				if (!slash) {
+					slash = linkpath;
+				}
+				else {
+					slash++;
+				}
+				plugin_entry_symbol = uwsgi_concat2n(slash, strlen(slash)-3, "",0);
+				up = dlsym(plugin_handle, plugin_entry_symbol);
+			}
+		}
+                free(plugin_name);
                 if (up) {
 			if (modifier != -1) {
 				fill_plugin_table(modifier, up);			
