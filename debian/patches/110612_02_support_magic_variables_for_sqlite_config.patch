Description: Support magic variables for/in SQLite3 configuration file
Author: Leonid Borisenko <leo.borisenko@gmail.com>
Bug: http://projects.unbit.it/uwsgi/ticket/18
Applied-Upstream: 0.9.8.1, http://projects.unbit.it/hg/uwsgi/rev/2817a1f422eb
Last-Update: 2011-06-13

Index: uwsgi/uwsgi.h
===================================================================
--- uwsgi.orig/uwsgi.h	2011-06-13 17:25:41.000000000 +0300
+++ uwsgi/uwsgi.h	2011-06-13 17:25:49.000000000 +0300
@@ -1566,7 +1566,7 @@
 #endif
 
 #ifdef UWSGI_SQLITE3
-void            uwsgi_sqlite3_config(char *);
+void            uwsgi_sqlite3_config(char *, char *[]);
 #endif
 
 
Index: uwsgi/uwsgi.c
===================================================================
--- uwsgi.orig/uwsgi.c	2011-06-13 17:25:49.000000000 +0300
+++ uwsgi/uwsgi.c	2011-06-13 17:25:49.000000000 +0300
@@ -1006,7 +1006,8 @@
 #endif
 #ifdef UWSGI_SQLITE3
 	if (uwsgi.sqlite3 != NULL) {
-		uwsgi_sqlite3_config(uwsgi.sqlite3);
+		config_magic_table_fill(uwsgi.sqlite3, magic_table);
+		uwsgi_sqlite3_config(uwsgi.sqlite3, magic_table);
 	}
 #endif
 #ifdef UWSGI_LDAP
@@ -1046,13 +1047,13 @@
 #endif
 #ifdef UWSGI_SQLITE3
 		if (!strcmp(uct->filename + strlen(uct->filename) - 3, ".db")) {
-			uwsgi_sqlite3_config(uct->filename);
+			uwsgi_sqlite3_config(uct->filename, magic_table);
 		}
 		if (!strcmp(uct->filename + strlen(uct->filename) - 7, ".sqlite")) {
-			uwsgi_sqlite3_config(uct->filename);
+			uwsgi_sqlite3_config(uct->filename, magic_table);
 		}
 		if (!strcmp(uct->filename + strlen(uct->filename) - 8, ".sqlite3")) {
-			uwsgi_sqlite3_config(uct->filename);
+			uwsgi_sqlite3_config(uct->filename, magic_table);
 		}
 #endif
 		uct = uct->next;
Index: uwsgi/sqlite3.c
===================================================================
--- uwsgi.orig/sqlite3.c	2011-06-13 17:25:41.000000000 +0300
+++ uwsgi/sqlite3.c	2011-06-13 17:25:49.000000000 +0300
@@ -5,18 +5,19 @@
 
 extern struct uwsgi_server uwsgi;
 
-static int uwsgi_sqlite3_config_callback(void *foo, int field_count, char **fields, char **col) {
-
+static int uwsgi_sqlite3_config_callback(void *magic_table, int field_count, char **fields, char **col) {
 	// make a copy of the string
 	if (field_count >= 2) {
-		add_exported_option( uwsgi_strncopy(fields[0], strlen(fields[0])), uwsgi_strncopy(fields[1], strlen(fields[1])), 0);
+		int value_len = strlen(fields[1]) + 1;
+		char *value = magic_sub(fields[1], value_len, &value_len, (char **) magic_table);
+		add_exported_option( uwsgi_strncopy(fields[0], strlen(fields[0])), value, 0);
 	}
 
 	return 0;
 }
 
 
-void uwsgi_sqlite3_config(char *file) {
+void uwsgi_sqlite3_config(char *file, char *magic_table[]) {
 
 	sqlite3 *db;
 	char *err = NULL;		
@@ -43,7 +44,7 @@
 		exit(1);
 	}
 
-	if (sqlite3_exec(db, query, uwsgi_sqlite3_config_callback, 0, &err)) {
+	if (sqlite3_exec(db, query, uwsgi_sqlite3_config_callback, (void *) magic_table, &err)) {
 		uwsgi_log("sqlite3 error: %s\n", err);
 		sqlite3_close(db);
 		exit(1);
