#!/bin/sh
### BEGIN INIT INFO
# Provides:          @@uwsgi_binary@@
# Required-Start:    $local_fs $remote_fs $network
# Required-Stop:     $local_fs $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop @@uwsgi_binary@@ server instance(s)
### END INIT INFO

# Author: Leonid Borisenko <leo.borisenko@gmail.com>

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="WSGI server(s)"             # Introduce a short description here
NAME="@@uwsgi_binary@@"           # Introduce the short server's name here
DAEMON=/usr/sbin/@@uwsgi_binary@@ # Introduce the server's location here
SCRIPTNAME=/etc/init.d/$NAME
CONFDIR=/etc/uwsgi/@@uwsgi_binary@@

RUNDIR=/var/run/uwsgi
UWSGI_RUNDIR=$RUNDIR/@@uwsgi_binary@@
DEFAULT_DAEMON_RUNDIR=$RUNDIR/default
DEFAULT_DAEMON_PIDFILE=$DEFAULT_DAEMON_RUNDIR/@@uwsgi_binary@@.pid
DEFAULT_DAEMON_SOCKET=$DEFAULT_DAEMON_RUNDIR/@@uwsgi_binary@@.socket

LOGDIR=/var/log/uwsgi
UWSGI_LOGDIR=$LOGDIR/@@uwsgi_binary@@
LOG_FILENAME_SUFFIX=@@uwsgi_binary@@

# Exit if the package is not installed
[ -x $DAEMON ] || exit 0

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

# Define supplementary functions
. /usr/lib/uwsgi/init/snippets
. /usr/lib/uwsgi/init/do_command

WHAT=$1
shift
case "$WHAT" in
  start|start-default)
    [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC " "$NAME"
    do_command "$WHAT" "$@"
    RETVAL="$?"
    [ "$VERBOSE" != no ] && log_end_msg "$RETVAL"
  ;;

  stop|stop-default)
    [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
    do_command "$WHAT" "$@"
    RETVAL="$?"
    [ "$VERBOSE" != no ] && log_end_msg "$RETVAL"
  ;;

  status)
    if [ -z "$1" ]; then
      status_of_proc -p $DEFAULT_DAEMON_PIDFILE "$DAEMON" "$NAME" \
        && exit 0 \
        || exit $?
    else
      status_of_proc -p $(find_specific_pidfile $1) "$DAEMON" "$NAME" \
        && exit 0 \
        || exit $?
    fi
  ;;

  reload|reload-default)
    [ "$VERBOSE" != no ] && log_daemon_msg "Reloading $DESC" "$NAME"
    do_command "$WHAT" "$@"
    RETVAL="$?"
    [ "$VERBOSE" != no ] && log_end_msg "$RETVAL"
  ;;

  force-reload|force-reload-default)
    [ "$VERBOSE" != no ] && log_daemon_msg "Forced reloading $DESC" "$NAME"
    do_command "$WHAT" "$@"
    RETVAL="$?"
    [ "$VERBOSE" != no ] && log_end_msg "$RETVAL"
  ;;

  restart|restart-default)
    SUFFIX_DEFAULT=""
    if [ "$WHAT" = "restart-default" ]; then
      SUFFIX_DEFAULT="-default"
    fi

    [ "$VERBOSE" != no ] && log_daemon_msg "Restarting $DESC" "$NAME"
    CURRENT_VERBOSE=$VERBOSE
    VERBOSE=no
    do_command "stop$SUFFIX_DEFAULT" "$@"
    VERBOSE=$CURRENT_VERBOSE
    case "$?" in
      0)
        do_command "start$SUFFIX_DEFAULT" "$@"
        RETVAL="$?"
        [ "$VERBOSE" != no ] && log_end_msg "$RETVAL"
      ;;
      *)
        # Failed to stop
        [ "$VERBOSE" != no ] && log_end_msg 1
      ;;
    esac
  ;;

  *)
    echo "Usage: $SCRIPTNAME {start|stop|status|restart|reload|force-reload}" >&2
    exit 3
  ;;
esac

:
